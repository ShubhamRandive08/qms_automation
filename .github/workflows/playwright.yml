name: Playwright Tests (Staged)

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: Environment to test
        required: true
        default: dev
        type: choice
        options: [dev, qa, staging, prod]
      test-type:
        description: Test type to run
        required: false
        default: all
        type: choice
        options: [smoke, regression, all]

permissions:
  contents: read

concurrency:
  group: playwright-staged-${{ github.ref }}
  cancel-in-progress: false

env:
  ENV_FROM_INPUT: ${{ github.event.inputs.environment || 'dev' }}
  TEST_TYPE_FROM_INPUT: ${{ github.event.inputs['test-type'] || 'all' }}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# â‘  BUILD / INSTALL  â†’  â‘¡ TEST  â†’  â‘¢ ALLURE  â†’  â‘£ SUMMARY  â†’  â‘¤ NOTIFY  â†’  â‘¥ PR COMMENT
# Every job is linked with `needs:` and guarded by `if: always()` so no job is skipped.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

jobs:

  build:
    name: â‘  Build / Install
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      env: ${{ steps.export-env.outputs.env }}   # just to demonstrate passing data
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Prepare environment
        id: export-env
        shell: bash
        run: |
          echo "ENV=${ENV_FROM_INPUT}" >> $GITHUB_ENV
          echo "TEST_TYPE=${TEST_TYPE_FROM_INPUT}" >> $GITHUB_ENV
          if [ -f ".env.${ENV_FROM_INPUT}" ]; then
            while IFS= read -r line || [[ -n "$line" ]]; do
              [[ "$line" =~ ^#|^$ ]] && continue
              key="${line%%=*}"
              val="${line#*=}"
              echo "$key=$val" >> $GITHUB_ENV
            done < ".env.${ENV_FROM_INPUT}"
          fi
          echo "env=${ENV_FROM_INPUT}" >> $GITHUB_OUTPUT

  test:
    name: â‘¡ Run Playwright Tests
    runs-on: ubuntu-latest
    needs: [build]
    if: always()         # <- ensures this job runs even if build failed
    timeout-minutes: 60
    outputs:
      exit_code: ${{ steps.run.outputs.exit_code }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: npm

      - name: Install deps (ensure)
        run: npm ci

      - name: Install Playwright browsers (ensure)
        run: npx playwright install --with-deps

      - name: Run tests
        id: run
        shell: bash
        run: |
          CMD="npx playwright test"
          case "${TEST_TYPE_FROM_INPUT}" in
            smoke) CMD="$CMD --grep @smoke" ;;
            regression) CMD="$CMD --grep @regression" ;;
          esac
          CMD="$CMD --reporter=html,github,line,allure-playwright"
          echo "Running: $CMD"
          set +e
          $CMD
          EC=$?
          echo "exit_code=$EC" >> $GITHUB_OUTPUT
          # do not fail the job; we want downstream to still run
          exit 0

      - name: Upload Playwright HTML
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/

      - name: Upload test-results (raw)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            test-results/
            allure-results/
            screenshots/
            videos/
          if-no-files-found: warn

  allure:
    name: â‘¢ Generate Allure
    runs-on: ubuntu-latest
    needs: [test]
    if: always()
    steps:
      - name: Download results
        uses: actions/download-artifact@v4
        with:
          name: test-results
          path: .

      - name: Install Allure CLI
        run: npm i -g allure-commandline || true

      - name: Build Allure report
        run: |
          if [ -d "allure-results" ]; then
            allure generate allure-results --clean -o allure-report
          else
            echo "No allure-results directory found."
          fi

      - name: Upload Allure report
        uses: actions/upload-artifact@v4
        with:
          name: allure-report
          path: allure-report/
          if-no-files-found: warn

  summary:
    name: â‘£ Create Summary
    runs-on: ubuntu-latest
    needs: [test]
    if: always()
    outputs:
      summary_file: ${{ steps.save.outputs.file }}
    steps:
      - name: Compose markdown summary
        id: compose
        shell: bash
        run: |
          STATUS="${{ needs.test.result }}"
          EXIT_CODE="${{ needs.test.outputs.exit_code }}"
          {
            echo "# ðŸ§ª Playwright Test Results"
            echo "- **Workflow Status:** ${STATUS}"
            echo "- **Test Exit Code:** ${EXIT_CODE}"
            echo "- **Environment:** ${ENV_FROM_INPUT}"
            echo "- **Test Type:** ${TEST_TYPE_FROM_INPUT}"
            echo "- **Run ID:** ${{ github.run_id }}"
            echo "- **Branch:** ${{ github.ref_name }}"
            echo "- **Actor:** ${{ github.actor }}"
            echo ""
            echo "Artifacts: Playwright HTML, Allure report, raw test-results"
          } > test-summary.md
          cat test-summary.md >> $GITHUB_STEP_SUMMARY

      - name: Save & upload summary
        id: save
        uses: actions/upload-artifact@v4
        with:
          name: test-summary
          path: test-summary.md

        # fake output so we can reference it (not strictly needed)
      - name: Expose file path
        id: expose
        run: echo "file=test-summary.md" >> $GITHUB_OUTPUT

  notify:
    name: â‘¤ Send Email
    runs-on: ubuntu-latest
    needs: [allure, summary]
    if: always()
    steps:
      - name: Send Email
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: "Playwright: ${{ needs.test.result }} - Run #${{ github.run_id }}"
          to: ${{ secrets.NOTIFICATION_EMAIL }}
          from: GitHub Actions <${{ secrets.EMAIL_USERNAME }}>
          body: |
            Status: ${{ needs.test.result }}
            Test exit code: ${{ needs.test.outputs.exit_code }}
            Run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
            Artifacts: playwright-report, allure-report, test-results, test-summary

  pr_comment:
    name: â‘¥ Update PR Comment
    runs-on: ubuntu-latest
    needs: [summary]
    if: github.event_name == 'pull_request' && always()
    permissions:
      contents: read
      pull-requests: write  # This is the key permission needed
    steps:
      - name: Download summary
        uses: actions/download-artifact@v4
        with:
          name: test-summary
          path: .

      - name: Comment / Update on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let body = fs.readFileSync('test-summary.md','utf8');
            const status = '${{ needs.summary.result }}' === 'success' ? 'âœ… SUCCESS' : 'âŒ FAILURE';
            body = `**Status:** ${status}\n\n` + body;

            const {data: comments} = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const mine = comments.find(c => c.user.type === 'Bot' && c.body.includes('Playwright Test Results'));
            if (mine) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: mine.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }
